------------------- Script-ul Python de generare a inserturilor -------------------------------
import random
import csv
import pandas as pd

fout = open('PopulateDatabase.sql', 'w')

LOCATIE_COUNT = 500
DEPOZIT_COUNT = 500
PLASARECOMANDA_COUNT = 1500
PRODUS_COUNT = 500
CURIER_COUNT = 500
DISPONIBILITATEDEPOZIT_COUNT = 1500
UTILIZATOR_COUNT = 500
LOCATIE_COUNT = 500
COMANDA_COUNT = 500
RECENZIE_COUNT = 500

alphanum1 = [chr(i) for i in range(ord('a'), ord('z') + 1)]
alphanum2 = [chr(i) for i in range(ord('A'), ord('Z') + 1)]
alphanum3 = [chr(i) for i in range(ord('0'), ord('9') + 1)]
alphanum = alphanum1 + alphanum2 + alphanum3 + [' ']

# array of arrays of form [city, country, subcountry, ]
cities = []
# array of arrays of form [product_name, Category, price, description]
products = None
# array of strings of firstnames
firstnames = None
# array of strings of lastnames
lastnames = None
# arrays of strings addresses
addresses = None
# arrays of arrays of from [Score, Text]
reviews = None
dates = None

# taken from amazon.com
categories = ['Books', 'Films', 'Games', 'TV', 'Electronics', 'Computers', 'PC', 'Home',
            'Garden', 'Beauty', 'Health', 'Toys', 'Children', 'Baby', 'Shoes',
            'Watches', 'Lingerie', 'Sports', 'Outdoors', 'Clothes']


def parse_csv(file: str):
    with open(file, encoding='cp850') as fin:
        csv_reader = csv.reader(fin)
        return [row for row in csv_reader][1:]

def parse_txt(file: str):
    with open(file, encoding='cp850') as fin:
        txt_reader = fin.read().split('\n')
        return txt_reader

def check(s: str):
    for c in s:
        if (c not in alphanum):
            return False
    return True

def ParseDatasets():
    global cities, products, firstnames, lastnames, addresses, reviews, dates
    
    # array of arrays of form [city, country, subcountry, geoid]
    cities = parse_csv('./datasets/worldcities.csv')
    cities = [row for row in cities if (check(row[0]) and check(row[1]))]

    products = parse_csv('./datasets/products.csv')
    products = [prod for prod in products if prod[2] != '']
    products = [prod for prod in products if ('\'' not in prod[3])]
    products = [prod for prod in products if (len(prod[3]) < 3000)]
    products = [prod for prod in products if (len(prod[0]) < 200)]
    products = [prod for prod in products if ('&' not in prod[3])]

    firstnames = parse_txt('./datasets/firstnames.txt')

    lastnames = parse_txt('./datasets/lastnames.txt')

    addresses = parse_txt('./datasets/addresses.txt')

    dates = parse_txt('./datasets/dates.txt')

    reviews = parse_csv('./datasets/recenzii.csv')
    reviews = [rew for rew in reviews if ('\'' not in rew[1])]
    reviews = [rew for rew in reviews if ('&' not in rew[1])]

def GetSQLDateParser(ddate):
    return 'to_date(\'{}\', \'yyyy-mm-dd hh24:mi:ss\')'.format(ddate)

def GenerateTelefon():
    return '07{}'.format(random.randint(10000000, 99999999))

def GenerateLocations():
    fout.write('--------- GENERATING LOCATIONS -----------------------------\n')
    for i in range(LOCATIE_COUNT):
        street = random.choice(addresses)
        gen_city = random.choice(cities)
        fout.write('insert into locatie values({}, \'{}\', \'{}\', \'{}\');\n'.format(
            i + 1, street, gen_city[0], gen_city[1]
        ))
    fout.write('\n\n\n\n')

def GenerateCurier():
    fout.write('--------------------- GENERATING CURIERI ----------------------\n')
    for i in range(CURIER_COUNT):
        curier_nume = random.choice(lastnames)
        curier_prenume = random.choice(firstnames)
        curier_telefon = GenerateTelefon()
        curier_email = '{}.{}@email.com'.format(curier_nume, curier_prenume)
        fout.write('insert into curier values({}, \'{}\', \'{}\', \'{}\',\'{}\');\n'.format(
            i + 1, curier_nume, curier_prenume, curier_telefon, curier_email
        ))
    fout.write('\n\n\n')

def GenerateDepozit():
    fout.write('-------------------- GENERATING DEPOZIT ----------------------\n')
    for i in range(DEPOZIT_COUNT):
        d_loc_id = random.randint(1, LOCATIE_COUNT)
        d_tel = GenerateTelefon()
        d_email = 'depozit_{}@email.com'.format(i)
        fout.write('insert into depozit values({}, {}, \'{}\', \'{}\');\n'.format(
            i + 1, d_loc_id, d_tel, d_email
        ))
    fout.write('\n\n\n')

def GenerateCategorie():
    fout.write('---------------------- GENERATING CATEGORIE ----------------------\n')
    for i in range(len(categories)):
        fout.write('insert into categorie(categorie_id, NumeCategorie) values({}, \'{}\');\n'.format(
            i + 1, categories[i]
        ))
    fout.write('\n\n\n')

def GenerateUtilizator():
    fout.write('---------------------- GENERATING UTILIZATOR ----------------------\n')
    # first 5 users are admins
    for i in range(1, 6):
        nume = random.choice(lastnames)
        prenume = random.choice(firstnames)
        email = '{}.{}@email.com'.format(nume, prenume)
        telefon = GenerateTelefon()
        locatie = random.randint(1, LOCATIE_COUNT)
        dataReg = random.choice(dates)
        tip = 'ADMIN'
        fout.write('insert into utilizator values({}, \'{}\', \'{}\', \'{}\', \'{}\', \'{}\', {}, {});\n'.format(
            i, nume, prenume, tip, email, telefon, GetSQLDateParser(dataReg), locatie
        ))
    # next 95 users are partners/sellers
    for i in range(6, 101):
        nume = random.choice(lastnames)
        prenume = random.choice(firstnames)
        email = '{}.{}@email.com'.format(nume, prenume)
        telefon = GenerateTelefon()
        locatie = random.randint(1, LOCATIE_COUNT)
        dataReg = random.choice(dates)
        tip = 'PARTENER'
        fout.write('insert into utilizator values({}, \'{}\', \'{}\', \'{}\', \'{}\', \'{}\', {}, {});\n'.format(
            i, nume, prenume, tip, email, telefon, GetSQLDateParser(dataReg), locatie
        ))
    # the rest 400 users are simple users
    for i in range(101, UTILIZATOR_COUNT + 1):
        nume = random.choice(lastnames)
        prenume = random.choice(firstnames)
        email = '{}.{}@email.com'.format(nume, prenume)
        telefon = GenerateTelefon()
        locatie = random.randint(1, LOCATIE_COUNT)
        dataReg = random.choice(dates)
        tip = 'USER'
        
        fout.write('insert into utilizator values({}, \'{}\', \'{}\', \'{}\', \'{}\', \'{}\', {}, {});\n'.format(
            i, nume, prenume, tip, email, telefon, GetSQLDateParser(dataReg), locatie
        ))
    fout.write('\n\n\n')

def GenerateProdus():
    fout.write('-------------------- GENERATING PRODUS -------------------\n')
    for i in range(PRODUS_COUNT):
        v_id = random.randint(1, 100)
        c_id = random.randint(1, len(categories))
        prod = random.choice(products)
        titlu = prod[0]
        descriere = prod[3]
        pret = float(prod[2])
        rating = random.randint(1, 10) / 2
        fout.write('insert into produs values({}, {}, {}, \'{}\', \'{}\', {:.2f}, {:.2f});\n'.format(
            i + 1, v_id, c_id, titlu, descriere, pret, rating
        ))
    fout.write('\n\n\n')

def GenerateRecenzie():
    fout.write('----------------- GENERATING RECENZIE --------------------\n')
    for i in range(RECENZIE_COUNT):
        u_id = random.randint(1, UTILIZATOR_COUNT)
        p_id = random.randint(1, PRODUS_COUNT)
        rew = random.choice(reviews)
        stele = float(rew[0])
        continut = rew[1]
        fout.write('insert into recenzie values({}, {}, {}, {:.2f}, \'{}\', sysdate);\n'.format(
            i + 1, u_id, p_id, stele, continut
        ))
    fout.write('\n\n\n')

def GenerateComanda():
    fout.write('----------------------- GENERATE COMANDA ---------------------\n')
    for i in range(COMANDA_COUNT):
        u_id = random.randint(1, UTILIZATOR_COUNT)
        c_id = random.randint(1, CURIER_COUNT)
        fout.write('insert into comanda values({}, {}, sysdate, {});\n'.format(
            i + 1, u_id, c_id
        ))
    fout.write('\n\n\n')

def GeneratePlasareComanda():
    fout.write('------------------------ GENERATE PLASARE COMANDA ---------------------\n')
    mydict = dict()
    for i in range(PLASARECOMANDA_COUNT):
        p_id = random.randint(1, PRODUS_COUNT)
        c_id = random.randint(1, COMANDA_COUNT)
        while ((p_id, c_id) in mydict):
            p_id = random.randint(1, PRODUS_COUNT)
            c_id = random.randint(1, COMANDA_COUNT)
        mydict.update({(p_id, c_id): 1})
        cantitate =random.randint(1, 50)
        fout.write('insert into PlasareComanda values({}, {}, {});\n'.format(
            p_id, c_id, cantitate
        ))
    fout.write('\n\n\n')

def GenerateDisponibilitateDepozit():
    fout.write('--------------------- GENERATE DISPONIBILITATE DEPOZIT -------------------\n')
    mydict = dict()
    for i in range(DISPONIBILITATEDEPOZIT_COUNT):
        p_id = random.randint(1, PRODUS_COUNT)
        d_id = random.randint(1, DEPOZIT_COUNT)
        while ((p_id, d_id) in mydict):
            p_id = random.randint(1, PRODUS_COUNT)
            d_id = random.randint(1, DEPOZIT_COUNT)
        mydict.update({(p_id, d_id) : 1})
        cantitate = random.randint(10, 500)
        fout.write('insert into DisponibilitateDepozit values({}, {}, {});\n'.format(
            p_id, d_id, cantitate
        ))
    fout.write('\n\n\n')

ParseDatasets()

GenerateLocations()
GenerateCurier()
GenerateDepozit()
GenerateUtilizator()
GenerateCategorie()
GenerateProdus()
GenerateRecenzie()
GenerateComanda()
GeneratePlasareComanda()
GenerateDisponibilitateDepozit()

fout.write('commit;')
fout.close()

# print(reviews[0])

------------------------------------- Script-ul SQL de creare ea entitatilor bazei de date --------------------------------
drop table Utilizator cascade constraints;
drop table Depozit cascade constraints;
drop table DisponibilitateDepozit cascade constraints;
drop table Produs cascade constraints;
drop table Recenzie cascade constraints;
drop table Locatie cascade constraints;
drop table Categorie cascade constraints;
drop table Comanda cascade constraints;
drop table PlasareComanda cascade constraints;
drop table Curier cascade constraints;

drop trigger audit_schema;
drop trigger logoff_write_logs;
drop table audit_user;
drop trigger shutdown_write_logs;
drop trigger log_erori;

create table Locatie(
	locatie_id number primary key,
	adresa     varchar2(100),
	oras       varchar2(100),
	tara	   varchar2(100)
);

create table Utilizator(
	utilizator_id		number primary key,
	nume				varchar2(20) not null,
	prenume				varchar2(20),
	tip 				varchar2(20) not null,
	email				varchar2(60),
	telefon				varchar2(10),
	DataInregistrare	date,
	locatie_id			number not null,
	foreign key (locatie_id) references Locatie(locatie_id) on delete set null
);

create table Categorie(
	categorie_id	number primary key,
	numeCategorie	varchar2(50),
	PretMinim		number,
	pretMaxim		number
);

create table Produs(
	produs_id		number primary key,
	vanzator_id		number not null,
	categorie_id	number not null,
	titlu			varchar2(200),
	descriere		varchar2(3000),
	pret			number(10, 2),
	rating			number(2, 1),
	foreign key (vanzator_id) references Utilizator(utilizator_id) on delete cascade,
	foreign key (categorie_id) references Categorie(categorie_id) on delete cascade
);

create table Recenzie(
	recenzie_id		number primary key,
	utilizator_id	number not null,
	produs_id		number not null,
	stele			number(2, 1),
	continut		varchar2(3000),
	data			date,
	foreign key (utilizator_id) references Utilizator(utilizator_id) on delete cascade,
	foreign key (produs_id) references Produs(produs_id) on delete cascade
);

create table Curier(
	curier_id		number primary key,
	nume			varchar2(20),
	prenume			varchar2(20),
	telefon			varchar2(10),
	email			varchar2(60)
);

create table Comanda(
	comanda_id		number primary key,
	utilizator_id	number not null,
	data			date,
	curier_id		number not null,
	foreign key (utilizator_id) references Utilizator(utilizator_id) on delete cascade,
	foreign key (curier_id) references Curier(curier_id) on delete set null
);

create table PlasareComanda(
	produs_id		number,
	comanda_id		number,
	cantitate		number,
	primary key (produs_id, comanda_id),
	foreign key (produs_id) references Produs(produs_id) on delete cascade,
	foreign key (comanda_id) references Comanda(comanda_id) on delete cascade
);

create table Depozit(
	depozit_id		number primary key,
	locatie_id		number not null,
	telefon			varchar2(10),
	email			varchar2(60),
	foreign key (locatie_id) references Locatie(locatie_id) on delete set null
);

create table DisponibilitateDepozit(
	produs_id		number,
	depozit_id		number,
	cantitate		number,
	primary key (produs_id, depozit_id),
	foreign key (produs_id) references Produs(produs_id) on delete cascade,
	foreign key (depozit_id) references Depozit(depozit_id) on delete cascade
);

describe locatie;
describe curier;
describe categorie;
describe utilizator;
describe produs;
describe recenzie;
describe depozit;
describe DisponibilitateDepozit;
describe comanda;
describe PlasareComanda;

-- Adaugam triggerii creati la cerintele 10, 11, 12 pentru ca au sens sa existe de la inceput

create or replace trigger SfarsitTrimestru
before insert or delete or update on PlasareComanda
begin
    if (to_char(sysdate, 'DD/MM') = '31/03' or
        to_char(sysdate, 'DD/MM') = '30/06' or
        to_char(sysdate, 'DD/MM') = '30/09' or
        to_char(sysdate, 'DD/MM') = '29/12') then
        
        raise_application_error(-20010, 'Plasarea/Modificarea/Stergerea comenzilor 
            este interzise in zilele in care se fac totalurile trimestrului!');
    end if;
end;
/

create or replace trigger categ_minmax_price
after insert or update on produs
for each row
declare
    min_pr      number;
    max_pr      number;
    categ       categorie%rowtype;
begin    
    min_pr := :new.pret;
    max_pr := :new.pret;
    
    select * into categ
    from categorie
    where categorie_id = :new.categorie_id;
    
    if nvl(categ.PretMinim, min_pr) < min_pr then
        min_pr := categ.PretMinim;
    end if;
    
    if nvl(categ.PretMaxim, max_pr) > max_pr then
        max_pr := categ.PretMaxim;
    end if;
    
    update categorie
    set PretMinim = min_pr,
        PretMaxim = max_pr
    where categorie_id = :new.categorie_id;
end;
/

create table audit_user(
    nume_bd             varchar2(50),
    user_logat          varchar2(30),
    eveniment           varchar2(100),
    tip_obiect_referit  varchar2(100),
    nume_obiect_referit varchar2(100),
    data                timestamp(3),
    nr_tabele           integer,
    nr_triggere         integer
);
/
create or replace trigger audit_schema
after create or drop or alter on schema
begin
    insert into audit_user values(
        sys.database_name,
        sys.login_user,
        sys.sysevent,
        sys.dictionary_obj_type,
        sys.dictionary_obj_name,
        systimestamp(3),
        (select count(*) from user_tables),
        (select count(*) from user_triggers)
    );
end;
/

-- presupunem ca exista directorul folosit de functie, si userul are acces la pachetele
-- utl_file si dbms_sql, precum si drepturi de read write asupra acelui director
create or replace procedure writelogs
is
    fisier  utl_file.file_type;
    p_sql_query varchar2(300):='select 
        nume_bd, user_logat, eveniment, tip_obiect_referit,
        nume_obiect_referit, data, nr_tabele, nr_triggere
    from audit_user';
    l_cursor_handle integer;
    l_dummy         number;
    l_rec_tab       dbms_sql.desc_tab;
    l_col_cnt       integer;
    l_current_line  varchar(2047);
    l_current_col   number(16);
    l_record_count  number(16):=0;
    l_column_value  varchar2(300);
    l_print_text    varchar2(300);
begin
    -- deschide fisierul pentru write
    fisier := utl_file.fopen('LOGS', 'logs.txt', 'w', 2047);
    
    -- deschide un cursor cu selectul din audit_user
    l_cursor_handle := dbms_sql.open_cursor;
    dbms_sql.parse(l_cursor_handle, p_sql_query, dbms_sql.native);
    l_dummy := dbms_sql.execute(l_cursor_handle);
    
    -- afla numele coloanelor
    dbms_sql.describe_columns(l_cursor_handle, l_col_cnt, l_rec_tab);
    
    -- append to file column headers
    l_current_col := l_rec_tab.first;
    if (l_current_col is not null) then
        loop
            dbms_sql.define_column(l_cursor_handle, l_current_col, l_column_value, 300);
            l_print_text := l_rec_tab(l_current_col).col_name || ' ';
            utl_file.put(fisier, l_print_text);
            l_current_col := l_rec_tab.next(l_current_col);
            exit when (l_current_col is null);
        end loop;
    end if;
    utl_file.put_line(fisier, ' ');
    
    -- append data for each row
    loop
        exit when dbms_sql.fetch_rows(l_cursor_handle) = 0;
        
        l_current_line := '';
        for l_current_col in 1..l_col_cnt loop
            dbms_sql.column_value(l_cursor_handle, l_current_col, l_column_value);
            l_print_text := l_column_value;
            
            l_current_line := l_current_line || l_column_value || ' ';
        end loop;
        
        l_record_count := l_record_count + 1;
        utl_file.put_line(fisier, l_current_line);
    end loop;
    
    utl_file.fclose(fisier);
    dbms_sql.close_cursor(l_cursor_handle);
    
exception
    when others then
        -- eliberam resursele de sistem
        if dbms_sql.is_open(l_cursor_handle) then
            dbms_sql.close_cursor(l_cursor_handle);
        end if;
        
        if utl_file.is_open(fisier) then
            utl_file.fclose(fisier);
        end if;
        
        dbms_output.put_line(dbms_utility.format_error_stack);
end;
/

create or replace trigger logoff_write_logs
before logoff on schema
begin
    writelogs;
end;
/

create or replace trigger log_erori
after servererror on schema
begin
    writelogs;
end;
/

create or replace trigger shutdown_write_logs
before shutdown on schema
begin
    writelogs;
end;
/

------------------------------------ Exemple de insert-uri generate de script-ul Python  ---------------------------------------------------------------
insert into locatie values(1, '7 HIGH', 'Florida', 'Uruguay');
insert into locatie values(2, '109 COLLEGE DR', 'Crevillente', 'Spain');
insert into locatie values(3, '1921 SE 22ND AVE SE', 'Zawiercie', 'Poland');
insert into locatie values(4, '509 PRESIDIO ST', 'Berrahal', 'Algeria');
insert into locatie values(5, '213 RED BUTTES ROAD RD', 'Hohhot', 'China');

insert into curier values(1, 'Forrester', 'Nonie', '0761941582','Forrester.Nonie@email.com');
insert into curier values(2, 'Bandara', 'Joanna', '0722838425','Bandara.Joanna@email.com');
insert into curier values(3, 'Marzan', 'Odelia', '0724456822','Marzan.Odelia@email.com');
insert into curier values(4, 'Javaid', 'Diana', '0734008006','Javaid.Diana@email.com');
insert into curier values(5, 'Frawley', 'Isaiah', '0758447333','Frawley.Isaiah@email.com');

insert into depozit values(1, 180, '0751952151', 'depozit_0@email.com');
insert into depozit values(2, 436, '0719864124', 'depozit_1@email.com');
insert into depozit values(3, 121, '0731820960', 'depozit_2@email.com');
insert into depozit values(4, 132, '0741490865', 'depozit_3@email.com');
insert into depozit values(5, 142, '0795319541', 'depozit_4@email.com');

insert into utilizator values(1, 'Segura', 'King', 'ADMIN', 'Segura.King@email.com', '0746679956', to_date('2020-02-29 20:32:14', 'yyyy-mm-dd hh24:mi:ss'), 439);
insert into utilizator values(2, 'Martineau', 'Byron', 'ADMIN', 'Martineau.Byron@email.com', '0752514058', to_date('2019-06-17 14:40:38', 'yyyy-mm-dd hh24:mi:ss'), 90);
insert into utilizator values(3, 'Abdulaziz', 'Arminta', 'ADMIN', 'Abdulaziz.Arminta@email.com', '0751168595', to_date('2019-08-02 11:03:39', 'yyyy-mm-dd hh24:mi:ss'), 387);
insert into utilizator values(4, 'Berk', 'Elzie', 'ADMIN', 'Berk.Elzie@email.com', '0735503716', to_date('2019-05-25 23:23:39', 'yyyy-mm-dd hh24:mi:ss'), 112);
insert into utilizator values(5, 'Kemp', 'Dana', 'ADMIN', 'Kemp.Dana@email.com', '0728884922', to_date('2019-07-04 02:47:23', 'yyyy-mm-dd hh24:mi:ss'), 151);

insert into categorie(categorie_id, NumeCategorie) values(1, 'Books');
insert into categorie(categorie_id, NumeCategorie) values(2, 'Films');
insert into categorie(categorie_id, NumeCategorie) values(3, 'Games');
insert into categorie(categorie_id, NumeCategorie) values(4, 'TV');
insert into categorie(categorie_id, NumeCategorie) values(5, 'Electronics');

insert into produs values(20, 93, 15, 'Wood Active Lifestyle Casual Shoes', 'Wood Active Lifestyle Casual Shoes - Buy Wood Active Lifestyle Casual Shoes - SPTY05 only for Rs. 1899 from Flipkart.com. Only Genuine Products. 30 Day Replacement Guarantee. Free Shipping. Cash On Delivery!', 26.59, 5.00);
insert into produs values(21, 70, 5, 'OEM 170906 Bike Centre Stand', 'Specifications of OEM 170906 Bike Centre Stand General Brand OEM Vehicle Model Name Activa Model Number 170906 Vehicle Brand Honda Type Centre Stand Material Stainless steel Color Black Dimensions Weight 1000 g In the Box 1 Bike Centre Stand', 40.60, 1.50);
insert into produs values(22, 18, 5, 'Lamex Timewear 3326-Black-Bk-1 Analog Watch  - For Women', 'Lamex Timewear 3326-Black-Bk-1 Analog Watch  - For Women - Buy Lamex Timewear 3326-Black-Bk-1 Analog Watch  - For Women  3326-Black-Bk-1 Online at Rs.799 in India Only at Flipkart.com. - Great Discounts, Only Genuine Products, 30 Day Replacement Guarantee, Free Shipping. Cash On Delivery!', 12.95, 1.50);
insert into produs values(23, 22, 4, 'UpTown Metal, Alloy Necklace', 'UpTown Metal, Alloy Necklace - Buy UpTown Metal, Alloy Necklace only for Rs. 230 from Flipkart.com. Only Genuine Products. 30 Day Replacement Guarantee. Free Shipping. Cash On Delivery!', 6.30, 4.50);
insert into produs values(24, 80, 2, 'Foot Jewel Women Wedges', 'Flipkart.com: Buy Foot Jewel Women Wedges only for Rs. 449 from Flipkart.com. Only Genuine Products. 30 Day Replacement Guarantee. Free Shipping. Cash On Delivery!', 18.19, 0.50);

insert into recenzie values(1, 291, 130, 5.00, 'I made these recently for a holiday party.  I have never seen anything go so fast!<br /><br />They were very easy to make-- just add a few ingredients, mix, and throw them in the oven.  I will definitely be buying and making these again.', sysdate);
insert into recenzie values(2, 461, 478, 5.00, 'This is amongst the best Karachi Halwa I have eaten. Not rubbery or super chewy like a lot of the other ones...just perfect.. individually wrapped pieces in the box.', sysdate);
insert into recenzie values(3, 458, 376, 5.00, 'I spotted the brand while watching "Everyday Italian" on the Food Channel. I drink it alone, as well as, adding it to brownies to make expresso brownies. Wonderful!', sysdate);
insert into recenzie values(4, 490, 16, 2.00, 'My pug is, perhaps, too spoiled when it comes to treats. I ordered the chicken and the beef and gave her the chicken first. She turned her nose away. I chopped it and added gravy. She ate the gravy. So I cannot attest to the effectiveness of the product.', sysdate);
insert into recenzie values(5, 434, 490, 5.00, 'Works with chicken fish beef or pork. Fast easy and makes it taste excellent. Plus buying in bulk is more than 50% off from box stores', sysdate);

insert into comanda values(1, 323, sysdate, 136);
insert into comanda values(2, 8, sysdate, 479);
insert into comanda values(3, 119, sysdate, 66);
insert into comanda values(4, 338, sysdate, 277);
insert into comanda values(5, 88, sysdate, 465);

insert into PlasareComanda values(486, 417, 19);
insert into PlasareComanda values(59, 159, 17);
insert into PlasareComanda values(33, 88, 28);
insert into PlasareComanda values(426, 102, 9);
insert into PlasareComanda values(200, 410, 25);

insert into DisponibilitateDepozit values(112, 6, 387);
insert into DisponibilitateDepozit values(118, 253, 223);
insert into DisponibilitateDepozit values(375, 66, 154);
insert into DisponibilitateDepozit values(57, 442, 74);
insert into DisponibilitateDepozit values(240, 89, 219);
insert into DisponibilitateDepozit values(392, 123, 432);

------------------------------------ Codul sursa SQL al cerintelor -------------------------------------------------------------------------------

-- Cerinta nr 6

-- Magazinul nostru vrea sa se asigure ca are un cashflow cat mai are.
-- Daca un produs este prea scump, nu va fi cumparat atat de des. Atunci
-- compania prefera sa isi micsoreze profitul per unitate si sa vanda
-- mai multe unitati.
-- Atfel, are nevoie de o procedura SQL care va micsora cu 5% pretul
-- la cel mai putin vandut produs in ultima luna.

set serveroutput on;

create or replace procedure AplicaReducere
is
    type tablou      is table of number index by binary_integer;
    type tablou_imbr is table of number;
    Produse tablou_imbr;
    
    function AflaProduse
    return tablou_imbr
    is
        v       tablou;
        rasp    tablou_imbr:=tablou_imbr();
        mn      number;
    begin
        for prod in (
            select * from produs
        ) loop
            v(prod.produs_id) := 0;
        end loop;
        
        for vanzare in (
            select pc.* from PlasareComanda pc, comanda c
            where pc.comanda_id = c.comanda_id and
                months_between(sysdate, c.data) <= 1
        ) loop
            v(vanzare.produs_id) := v(vanzare.produs_id) + vanzare.cantitate;
        end loop;
        
        mn := v(v.first);
        for i in v.first .. v.last loop
            if v(i) < mn then
                mn := v(i);
                rasp.delete(rasp.first, rasp.last);
                rasp.extend;
                rasp(rasp.last) := i;
            elsif v(i) = mn then
                rasp.extend;
                rasp(rasp.last) := i;
            end if;
        end loop;
        
        return rasp;
    -- nu poate exista exceptia no data found, deoarece apelam functia 
    -- facand un group by inainte
    -- nu poate exista exceptia too many rows deoarece avem where
    -- rownum <= 1
    end AflaProduse;
    
begin
    Produse := AflaProduse;
    
    for i in Produse.first .. Produse.last loop
        update produs
        set pret = round(0.95 * pret, 2)
        where produs_id = Produse(i);
    end loop;
    commit;
end;
/

Execute AplicaReducere;


-- Cerinta nr 7

-- Magazinul nostru online vrea ca atunci cand intr-un depozit se afla putine
-- unitati ale unui produs, sa organizeze o promotie de lichidare de stoc,
-- pentru a face loc pentru alte produse.
-- Astfel, are nevoie de functie care la orice moment de timp, sa afiseze
-- pentru fiecare produs detaliile depozitului ce contine cantitatea cea mai mica
-- de produs respectiv. Evident ne intereseaza doar depozitele care au macar o
-- unitate de produs respectiv.
-- Daca un produs nu se afla in nici o cantitate
-- in vreunul din depozite, nu i se poate organiza o promotie de lichidare de stoc, 
-- deci nu ne intereseaza.

-- Vom defini un subprogram si vom folosi un ciclu cursor

set serveroutput on;

create or replace procedure LichidareStoc
is
    type tablou is table of number index by binary_integer;
    Depozite    tablou;
    prod_id      number;
    
    function DepozitCantitateMin(
        prod_id     number
    )
    return number
    is
        dep_id  number;
    begin
        select depozit_id
        into dep_id
        from (
            select * from DisponibilitateDepozit
            where produs_id = prod_id
            order by cantitate
        )
        where rownum <= 1;
        
        return dep_id;
    -- nu poate exista exceptia no data found, deoarece apelam functia 
    -- facand un group by inainte
    -- nu poate exista exceptia too many rows deoarece avem where
    -- rownum <= 1
    end DepozitCantitateMin;
    
begin
    for dp in (
        select produs_id from DisponibilitateDepozit
        group by produs_id) loop
        Depozite(dp.produs_id) := DepozitCantitateMin(dp.produs_id);
    end loop;
    
    for i in Depozite.first .. Depozite.last loop
        if Depozite.exists(i) then
            dbms_output.put_line('Produs id: '|| i||' Depozit id: '||Depozite(i));
        end if;
    end loop;
end;
/

Execute LichidareStoc;



-- Cerinta nr 8

-- Administratorii site-ului vor sa stie pentru fiecare categorie de produse,
-- care e depozitul care detine cea mai mare cantitate de produse din acea
-- categorie.

-- Avem nevoie de tabelele Categorie, Produs, si DisponibilitateDepozit

set serveroutput on;

-- Functia va returna numarul de Categorii care se regasesc in macar un depozit
create or replace function IdentificareDepozite
return number
is
    type tablou      is table of number index by binary_integer;
    type tablou_string is table of categorie.NumeCategorie%type index by binary_integer;
    Categorii        tablou;
    NumeCategorii    tablou_string;
    dep_id           number;
    ans              number := 0;
    
begin
    for categ in (
        select * from categorie
    ) loop
        NumeCategorii(categ.categorie_id) := categ.NumeCategorie;
        begin
            select depozit_id into dep_id
            from (
                select dp.depozit_id, sum(dp.cantitate) as numar_produse
                from produs p, DisponibilitateDepozit dp
                where p.categorie_id = categ.categorie_id and
                    dp.produs_id = p.produs_id
                group by dp.depozit_id
                order by numar_produse desc                    
            )
            where rownum <= 1;
            Categorii(categ.categorie_id) := dep_id;
        exception
            -- nu putem avea exceptia too many rows deoarece am un
            -- where rownum <= 1, deci putem avea maxim 1 rezultat
            when no_data_found then
                Categorii(categ.categorie_id) := null;
        end;
    end loop;
    
    for i in Categorii.first .. Categorii.last loop
        if Categorii(i) is null then
            dbms_output.put_line('Categoria '||NumeCategorii(i)||' nu se regaseste in niciun depozit');
        else
            dbms_output.put_line('Categoria: '|| NumeCategorii(i));
            dbms_output.put_line('Depozitul cu id-ul: '|| Categorii(i));
            ans := ans + 1;
        end if;
    end loop;
    return ans;
end;
/

begin
    dbms_output.put_line('Categorii care se regasesc in cel putin 1 depozit: '||IdentificareDepozite());
end;

-- Adaugam o categorie noua, astfel suntem siguri ca nu se regaseste
-- in niciun depozit
insert into categorie(categorie_id, NumeCategorie) values((select max(categorie_id) from categorie) + 1, 'CategorieNula');
begin
    dbms_output.put_line('Categorii care se regasesc in cel putin 1 depozit: '||IdentificareDepozite());
end;
rollback;


-- Cerinta nr 9

-- Magazinul are nevoie de o procedura care sa afle valoarea comenzilor plasata de userii
-- dintr-un anumit oras, in primele k luni de la crearea contului

-- Avem nevoie de tabelele Locatie, Utilizator, Comanda, Produs si PlasareComanda

set serveroutput on;

-- Functia va returna numarul de Categorii care se regasesc in macar un depozit
create or replace procedure VizualizareComenzi(
    nume_oras    locatie.oras%type,
    k            integer
)
is
    type tip_raspuns is record (utilizator_id   utilizator.utilizator_id%type,
                                nume            utilizator.nume%type,
                                prenume         utilizator.prenume%type,
                                valoare         number);
    type tablou is table of tip_raspuns;
    raspuns tablou;
    cnt     integer;
    
    function AflaPretProdus(
        prod_id     produs.produs_id%type
    ) return produs.pret%type
    is
        prod_pret   number;
    begin
        select pret into prod_pret
        from produs
        where produs_id = prod_id;
        
        return prod_pret;
    exception
        when no_data_found then
            raise_application_error(-20003, 'Nu exista produs cu id-ul dat in baza de date');
        -- nu putem avea exceptia too many rows doarece produs_id este cheie primara
    end AflaPretProdus;
    
    function AflaDataInregistrare(
        u_id    utilizator.utilizator_id%type
    ) return utilizator.DataInregistrare%type
    is
        dataReg     utilizator.DataInregistrare%type;
    begin
        select DataInregistrare into dataReg
        from utilizator
        where utilizator_id = u_id;
        
        return dataReg;
    exception
        when no_data_found then
            raise_application_error(-20000, 'Nu exista utilizator cu acest id');
        -- nu putem avea exceptia too many rows deoarece utilizator_id este cheie primara
    end AflaDataInregistrare;        
    
    function AflaValoareComenzi(
        u_id    utilizator.utilizator_id%type
    )
    return number
    is
        suma        number:=0;
        dataReg     date;
    begin   
        dataReg := AflaDataInregistrare(u_id);
        for my_comanda in (
            select pc.* from comanda c, PlasareComanda pc
            where utilizator_id = u_id and
                months_between(data, dataReg) <= k and
                c.comanda_id = pc.comanda_id
        ) loop
            suma := suma + my_comanda.cantitate * AflaPretProdus(my_comanda.produs_id);
        end loop;
        return suma;
    end AflaValoareComenzi;
begin
    select count(*) into cnt
    from locatie
    where oras = nume_oras;
    
    if cnt = 0 then
        raise_application_error(-20001, 'Nu exista oras cu numele dat in baza de date');
    end if;
    
    if k < 0 then
        raise_application_error(-20002, 'S-a dat un numar negativ de luni ca parametru');
    end if;
    
    select u.utilizator_id, u.nume, u.prenume, 0 as valoare
    bulk collect into raspuns
    from utilizator u, locatie l
    where l.oras = nume_oras and
        l.locatie_id = u.locatie_id;
    
    dbms_output.put_line('Valoarea comenzilor utilizatorilor din orasul '||nume_oras||
        ' in ultimele '||k||' luni');
    dbms_output.put_line('Id | Nume | Prenume | Valoarea comenzilor');
    for i in raspuns.first .. raspuns.last loop
        raspuns(i).valoare := AflaValoareComenzi(raspuns(i).utilizator_id);
        dbms_output.put_line(raspuns(i).utilizator_id||' '|| raspuns(i).nume||' '
            ||raspuns(i).prenume||' '||raspuns(i).valoare);
    end loop;
exception
    when no_data_found then
        raise_application_error(-20001, 'Nu exista oras cu numele dat in baza de date');
end;
/

-- trebuie pasat un oras care sa exista, sa consultam mai intai tabelul locatie
execute VizualizareComenzi('Tochigi', 100);

-- Dam un oras care nu exista
execute VizualizareComenzi('ABCD', 1);

-- Dam un numar negativ ca parametru pentru numarul de luni
execute VizualizareComenzi('Bucuresti', -1);


-- Cerinta 10

-- Magazinul isi face totalurile in activitatilor economice la sfarsitul fiecarui
-- trimestru. In momentul in care face aceste totaluri, vrem sa ne asiguram ca
-- datele sunt consistente, astfel nu vrem ca o cumparatura facuta sa apara intr-un
-- calcul, iar in altul nu (daca de exemplu intre completarea fisierelor/tabelelor
-- 1 si 2 se mai face o comanda).
-- Solutia este ca in momentul in care se efectueaza aceste totaluri, sa fie blocata
-- posbilitatea plasarii unei comenzi. Totalurile se fac in cadrul orelor de lucru.

-- Astfel, in fiecare an, pe 31 martie, 30 iunie, 30 septembrie, 31 decembrie,
-- in intervalul de ore 9:00-17:00, este blocata posibilitatea plasarii unei comenzi.

set serveroutput on;

create or replace trigger SfarsitTrimestru
before insert or delete or update on PlasareComanda
begin
    if (to_char(sysdate, 'DD/MM') = '31/03' or
        to_char(sysdate, 'DD/MM') = '30/06' or
        to_char(sysdate, 'DD/MM') = '30/09' or
        to_char(sysdate, 'DD/MM') = '29/12') then
        
        raise_application_error(-20010, 'Plasarea/Modificarea/Stergerea comenzilor 
            este interzise in zilele in care se fac totalurile trimestrului!');
    end if;
end;
/

-- Pentru declansare incercam o inserare fie in una din cele 4 dati de mai sus,
-- fie adaugam in if sa verifice pentru ziua curenta
insert into PlasareComanda values(1, 3, 1);

-- Cerinta 11

-- Vrem sa mentinem in tabelul de categorii niste contoare a pretului minim
-- respectiv maxim a unui produs din acea categorie.
-- Astfel, trebuie sa avem grija sa modificam aceste campuri cand se adauga
-- un produs nou, sau modifica unul existent, intrucat nu trebuie sa fie
-- grija unui utilizator simplu a bazei de date.

-- Il facem trigger de tip after ca sa se faca automat check-urile constrangerii
-- de tip foreign key

create or replace trigger categ_minmax_price
after insert or update on produs
for each row
declare
    min_pr      number;
    max_pr      number;
    categ       categorie%rowtype;
begin    
    min_pr := :new.pret;
    max_pr := :new.pret;
    
    select * into categ
    from categorie
    where categorie_id = :new.categorie_id;
    
    if nvl(categ.PretMinim, min_pr) < min_pr then
        min_pr := categ.PretMinim;
    end if;
    
    if nvl(categ.PretMaxim, max_pr) > max_pr then
        max_pr := categ.PretMaxim;
    end if;
    
    update categorie
    set PretMinim = min_pr,
        PretMaxim = max_pr
    where categorie_id = :new.categorie_id;
end;
/

-- Pentru declansare, inseram un produs nou
insert into Produs(produs_id, vanzator_id, categorie_id, titlu)
values ((select max(produs_id) from produs) + 1, 1, 1, 'Produs Test');
rollback;


-- Cerinta 12

-- Vom face un sistem de log-uri pentru baza noastra de date
-- pentru aceasta vom avea nevoie de mai multe privilegii de trebuie acordate
-- de administratorul bazei de date utilizatorului nostru.

-- grant execute on utl_file to constantin;
-- permite folosirea pachetului utl_file, ce are definite functii de IO cu fisier

-- grant execute on dbms_sql to constantin;
-- permite folosirea pachetului dbms_sql, pentru a putea deschide cursori in
-- modul necesar noua

-- create directory logs as 'E:\OracleLogs';
-- creaza folder-ul unde vor fi scrise log-urile;

-- grant read, write on directory logs to constantin;
-- da privilegiile necesare pentru a putea face operatii de IO in acel directory

set serveroutput on;
/

create table audit_user(
    nume_bd             varchar2(50),
    user_logat          varchar2(30),
    eveniment           varchar2(100),
    tip_obiect_referit  varchar2(100),
    nume_obiect_referit varchar2(100),
    data                timestamp(3),
    nr_tabele           integer,
    nr_triggere         integer
);
/
create or replace trigger audit_schema
after create or drop or alter on schema
begin
    insert into audit_user values(
        sys.database_name,
        sys.login_user,
        sys.sysevent,
        sys.dictionary_obj_type,
        sys.dictionary_obj_name,
        systimestamp(3),
        (select count(*) from user_tables),
        (select count(*) from user_triggers)
    );
end;
/

-- Combinand acest trigger cu unul care sa scrie intr-un fisier aceste loguri
-- atunci cand user-ul iese, sau baza de date se inchide sau intampina o
-- eroare, o sa avem aceste loguri fara nevoia de a mai intra inapoi in baza
-- de date.

-- vom defini o functie ce o vom utiliza in urmatoarele triggere
-- dupa executarea acestei functii, in directorul si fisierul cu numele specificat, se va afla
-- continutul tabelului audit_schema
create or replace procedure writelogs
is
    fisier  utl_file.file_type;
    p_sql_query varchar2(300):='select 
        nume_bd, user_logat, eveniment, tip_obiect_referit,
        nume_obiect_referit, data, nr_tabele, nr_triggere
    from audit_user';
    l_cursor_handle integer;
    l_dummy         number;
    l_rec_tab       dbms_sql.desc_tab;
    l_col_cnt       integer;
    l_current_line  varchar(2047);
    l_current_col   number(16);
    l_record_count  number(16):=0;
    l_column_value  varchar2(300);
    l_print_text    varchar2(300);
begin
    -- deschide fisierul pentru write
    fisier := utl_file.fopen('LOGS', 'logs.txt', 'w', 2047);
    
    -- deschide un cursor cu selectul din audit_user
    l_cursor_handle := dbms_sql.open_cursor;
    dbms_sql.parse(l_cursor_handle, p_sql_query, dbms_sql.native);
    l_dummy := dbms_sql.execute(l_cursor_handle);
    
    -- afla numele coloanelor
    dbms_sql.describe_columns(l_cursor_handle, l_col_cnt, l_rec_tab);
    
    -- append to file column headers
    l_current_col := l_rec_tab.first;
    if (l_current_col is not null) then
        loop
            dbms_sql.define_column(l_cursor_handle, l_current_col, l_column_value, 300);
            l_print_text := l_rec_tab(l_current_col).col_name || ' ';
            utl_file.put(fisier, l_print_text);
            l_current_col := l_rec_tab.next(l_current_col);
            exit when (l_current_col is null);
        end loop;
    end if;
    utl_file.put_line(fisier, ' ');
    
    -- append data for each row
    loop
        exit when dbms_sql.fetch_rows(l_cursor_handle) = 0;
        
        l_current_line := '';
        for l_current_col in 1..l_col_cnt loop
            dbms_sql.column_value(l_cursor_handle, l_current_col, l_column_value);
            l_print_text := l_column_value;
            
            l_current_line := l_current_line || l_column_value || ' ';
        end loop;
        
        l_record_count := l_record_count + 1;
        utl_file.put_line(fisier, l_current_line);
    end loop;
    
    utl_file.fclose(fisier);
    dbms_sql.close_cursor(l_cursor_handle);
    
exception
    when others then
        -- eliberam resursele de sistem
        if dbms_sql.is_open(l_cursor_handle) then
            dbms_sql.close_cursor(l_cursor_handle);
        end if;
        
        if utl_file.is_open(fisier) then
            utl_file.fclose(fisier);
        end if;
        
        dbms_output.put_line(dbms_utility.format_error_stack);
end;
/

create or replace trigger logoff_write_logs
before logoff on schema
begin
    writelogs;
end;
/

create or replace trigger log_erori
after servererror on schema
begin
    writelogs;
end;
/

create or replace trigger shutdown_write_logs
before shutdown on schema
begin
    writelogs;
end;
/


-- Cerinte 13

set serveroutput on;

create or replace package proiect
is
    type tablou         is table of number index by binary_integer;
    type tablou_imbr    is table of number;
    type tip_rasp_com   is record(
        utilizator_id   utilizator.utilizator_id%type,
        nume            utilizator.nume%type,
        prenume         utilizator.prenume%type,
        valoare         number);
    type tablou_raspuns is table of tip_rasp_com;
    
    procedure AplicaReducere;
    
    function AflaProduse return tablou_imbr;
    
    procedure LichidareStoc;
    
    function DepozitCantitateMin(
        prod_id     number
    ) return number;
    
    procedure VizualizareComenzi(
        nume_oras   locatie.oras%type,
        k           integer);
    
    function AflaPretProdus(
        prod_id     produs.produs_id%type
    ) return produs.pret%type;
    
    function AflaValoareComenzi(
        u_id        utilizator.utilizator_id%type,
        k           integer
    ) return number;
end proiect;
/

create or replace package body proiect
is
    function AflaProduse
    return tablou_imbr
    is
        v       tablou;
        rasp    tablou_imbr:=tablou_imbr();
        mn      number;
    begin
        for prod in (
            select * from produs
        ) loop
            v(prod.produs_id) := 0;
        end loop;
        
        for vanzare in (
            select pc.* from PlasareComanda pc, Comanda c
            where pc.comanda_id = c.comanda_id and
                months_between(sysdate, c.data) <= 1
        ) loop
            v(vanzare.produs_id) := v(vanzare.produs_id) + vanzare.cantitate;
        end loop;
        
        mn := v(v.first);
        for i in v.first .. v.last loop
            if v(i) < mn then
                rasp.delete(rasp.first, rasp.last);
                rasp.extend;
                rasp(rasp.last) := i;
            elsif v(i) = mn then
                rasp.extend;
                rasp(rasp.last) := i;
            end if;
        end loop;
        
        return rasp;
    end Aflaproduse;
    
    procedure AplicaReducere
    is
        Produse     tablou_imbr;
    begin
        Produse := AflaProduse;
        
        for i in Produse.first .. Produse.last loop
            update produs
            set pret = round(0.95 * pret, 2)
            where produs_id = Produse(i);
        end loop;
        commit;
    end AplicaReducere;
    
    function DepozitCantitateMin(
        prod_id     number
    ) return number
    is
        dep_id  number;
    begin
        select depozit_id into dep_id
        from (
            select * from DisponibilitateDepozit
            where produs_id = prod_id
            order by cantitate
        )
        where rownum <= 1;
        
        return dep_id;
    exception
        when no_data_found then
            raise_application_error(-20020, 'Produsul dat nu se gaseste in
                niciun depozit');
    end DepozitcantitateMin;
    
    procedure LichidareStoc
    is
        Depozite    tablou;
        prod_id     number;
    begin
        for dp in (
            select produs_id from DisponibilitateDepozit
            group by produs_id) loop
            
            Depozite(dp.produs_id) := DepozitCantitateMin(dp.produs_id);
        end loop;
        
        for i in Depozite.first .. Depozite.last loop
            if Depozite.exists(i) then
                dbms_output.put_line('Produs id: '||i||' Depozit id: '||Depozite(i));
            end if;
        end loop;
    end LichidareStoc;
    
    function AflaPretProdus(
        prod_id     produs.produs_id%type
    ) return produs.pret%type
    is
        prod_pret   number;
    begin
        select pret into prod_pret
        from produs
        where produs_id = prod_id;
        
        return prod_pret;
    exception
        when no_data_found then
            raise_application_error(-20021, 'Nu exista produs cu id-ul dat');
    end AflaPretProdus;
    
    function AflaDataInregistrare(
        u_id    utilizator.utilizator_id%type
    ) return utilizator.DataInregistrare%type
    is
        dataReg     utilizator.DataInregistrare%type;
    begin
        select DataInregistrare into dataReg
        from utilizator
        where utilizator_id = u_id;
        
        return dataReg;
    exception
        when no_data_found then
            raise_application_error(-20022, 'Nu exista utilizator cu acest id');
    end AflaDataInregistrare;
    
    function AflaValoareComenzi(
        u_id    utilizator.utilizator_id%type,
        k       integer
    ) return number
    is
        suma    number:=0;
        dataReg date;
    begin
        dataReg := AflaDataInregistrare(u_id);
        for my_comanda in (
            select pc.* from comanda c, PlasareComanda pc
            where utilizator_id = u_id and
                months_between(data, dataReg) <= k and
                c.comanda_id = pc.comanda_id
        ) loop
            suma := suma + my_comanda.cantitate * AflaPretProdus(my_comanda.produs_id);
        end loop;
        
        return suma;
    end AflaValoareComenzi;
    
    procedure VizualizareComenzi(
        nume_oras       locatie.oras%type,
        k               integer)
    is
        raspuns     tablou_raspuns;
        cnt         integer;
    begin
        select count(*) into cnt
        from locatie
        where oras = nume_oras;
        
        if cnt = 0 then
            raise_application_error(-20023, 'Nu exista oras cu numele dat in baza de date');
        end if;
        
        if k < 0 then
            raise_application_error(-20024, 'S-a dat un numar negativ de luni ca parametru');
        end if;
        
        select u.utilizator_id, u.nume, u.prenume, 0 as valoare
        bulk collect into raspuns
        from utilizator u, locatie l
        where l.oras = nume_oras and
            l.locatie_id = u.locatie_id;
        
        dbms_output.put_line('Valoarea comenzilor utilizatorilor din orasul '||nume_oras||
            ' in ultimele '||k||' luni');
        dbms_output.put_line('Id | Nume | Prenume | Valoarea comenzilor');
        for i in raspuns.first .. raspuns.last loop
            raspuns(i).valoare := AflaValoareComenzi(raspuns(i).utilizator_id, k);
            dbms_output.put_line(raspuns(i).utilizator_id||' '|| raspuns(i).nume||' '
                ||raspuns(i).prenume||' '||raspuns(i).valoare);
        end loop;
    exception
    when no_data_found then
        raise_application_error(-20001, 'Nu exista oras cu numele dat in baza de date');
    end VizualizareComenzi;
end proiect;
/


-- Cerinta 14

-- Un pachet ce contine functiile necesare pentru a scrie continutul unui tabel intr-un fisier

create or replace package wfile
is
    procedure write_to_file(
        nume_tabel      user_tables.table_name%type,
        nume_fisier     varchar2
    );
    
    procedure check_table_exists(
        nume_tabel  user_tables.table_name%type
    );
end wfile;
/

create or replace package body wfile
is
    procedure check_table_exists(
        nume_tabel   user_tables.table_name%type
    )
    is
        cnt integer;
    begin
        select count(*) into cnt
        from user_tables
        where lower(table_name) = lower(nume_tabel);
        
        if (cnt = 0) then
            raise_application_error(-20050, 'Nu exista acest tabel in user space');
        end if;
        return;
    end check_table_exists;
    
    procedure write_to_file(
        nume_tabel      user_tables.table_name%type,
        nume_fisier     varchar2)
    is
        fisier          utl_file.file_type;
        p_sql_query     varchar2(300):='select * from ';
        l_cursor_handle integer;
        l_dummy         number;
        l_rec_tab       dbms_sql.desc_tab;
        l_col_cnt       integer;
        l_current_line  varchar(2047);
        l_current_col   number(16);
        l_record_count  number(16):=0;
        l_column_value  varchar2(300);
        l_print_text    varchar2(300);
    begin
        check_table_exists(nume_tabel);
    
        p_sql_query := p_sql_query || nume_tabel;
        -- deschide fisierul pentru write
        -- LOGS reprezinta un directory creat din sql, ce are incorporata si adresa pe disk unde se va scrie fisierul
        -- pentru a scrie in alta locatie, trebuie sa declaram acel directory, si sa acordam drepturi de read-write
        -- utilizatorului pentru acel fisier
        fisier := utl_file.fopen('LOGS', nume_fisier, 'w', 2047);
        
        -- deschide un cursor cu selectul din audit_user
        l_cursor_handle := dbms_sql.open_cursor;
        dbms_sql.parse(l_cursor_handle, p_sql_query, dbms_sql.native);
        l_dummy := dbms_sql.execute(l_cursor_handle);
        
        -- afla numele coloanelor
        dbms_sql.describe_columns(l_cursor_handle, l_col_cnt, l_rec_tab);
        
        -- append to file column headers
        l_current_col := l_rec_tab.first;
        if (l_current_col is not null) then
            loop
                dbms_sql.define_column(l_cursor_handle, l_current_col, l_column_value, 300);
                l_print_text := l_rec_tab(l_current_col).col_name || ' ';
                utl_file.put(fisier, l_print_text);
                l_current_col := l_rec_tab.next(l_current_col);
                exit when (l_current_col is null);
            end loop;
        end if;
        utl_file.put_line(fisier, ' ');
        
        -- append data for each row
        loop
            exit when dbms_sql.fetch_rows(l_cursor_handle) = 0;
            
            l_current_line := '';
            for l_current_col in 1..l_col_cnt loop
                dbms_sql.column_value(l_cursor_handle, l_current_col, l_column_value);
                l_print_text := l_column_value;
                
                l_current_line := l_current_line || l_column_value || ' ';
            end loop;
            
            l_record_count := l_record_count + 1;
            utl_file.put_line(fisier, l_current_line);
        end loop;
        
        utl_file.fclose(fisier);
        dbms_sql.close_cursor(l_cursor_handle);
        
    exception
        when others then
            -- eliberam resursele de sistem
            if dbms_sql.is_open(l_cursor_handle) then
                dbms_sql.close_cursor(l_cursor_handle);
            end if;
            
            if utl_file.is_open(fisier) then
                utl_file.fclose(fisier);
            end if;
            
            dbms_output.put_line(dbms_utility.format_error_stack);
    end write_to_file;
    
end wfile;
/


Execute wfile.write_to_file('audit_user', 'test.txt');